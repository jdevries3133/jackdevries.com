---
title: "Git: Some Help"
description: A tutorial for shell aliases, staging hunks, cherry-picking, understanding merge commits, reverting commits, the ref log, and interactive rebasing.
created: 2022-10-16
thumbnail: /static/gitSomeHelp.webp
---

import { CodeSample } from '../components/codeSample';
import { Image } from '../components/image';

# Git: Some Help

<video muted controls loop  autoPlay>
    <source src="/static/gitSomeHelp.mp4" type="video/mp4" />
</video>

This is a tutorial for the following topics:

- shell aliases
- staging hunks (`git add -i`)
- cherry-picking
- understanding merge commits
- reverting commits

## Shell Aliases

Off the top of my head, here are a few aliases I use almost every day, and you
can see how much typing they save.

<table>
  <thead>
    <tr>
      <td>Alias</td>
      <td>Command</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ga</code></td>
      <td><code>git add</code></td>
    </tr>
    <tr>
      <td><code>gc</code></td>
      <td><code>git commit</code></td>
    </tr>
    <tr>
      <td><code>gca</code></td>
      <td><code>git commit --amend</code></td>
    </tr>
    <tr>
      <td><code>gcan!</code></td>
      <td><code>git commit --amend --no-edit</code></td>
    </tr>
    <tr>
      <td><code>gpsup</code></td>
      <td><code>git push --set-upstream $CURRENT_BRANCH</code></td>
    </tr>
    <tr>
      <td><code>gl</code></td>
      <td><code>git pull</code></td>
    </tr>
    <tr>
      <td><code>gmom</code></td>
      <td><code>git merge origin/master</code></td>
    </tr>
    <tr>
      <td><code>gst</code></td>
      <td><code>git status</code></td>
    </tr>
    <tr>
      <td><code>gwip</code></td>
      <td><code>{`git add -A; git rm $(git ls-files --deleted) 2> /dev/null; git commit --no-verify --no-gpg-sign -m "--wip-- [skip ci]`}</code></td>
    </tr>
    <tr>
      <td><code>gunwip</code></td>
      <td><code>git log -n 1 | grep -q -c "\-\-wip\-\-" && git reset HEAD~1</code></td>
    </tr>
  </tbody>
</table>

I didn't write these aliases; they come from [oh-my-zsh](https://ohmyz.sh/). If
you don't use zsh or don't want install all of oh-my-zsh, [the source code for
the git aliases is
here](https://github.com/ohmyzsh/ohmyzsh/blob/master/plugins/git/git.plugin.zsh#L56-L322).
You can copy and paste this into your `~/.bashrc` if you use bash, or adapt
them to whatever terminal you use.

In particular, we are going to use the `gwip` and `gunwip` commands throughout
this guide to create various scenarios, so copy and paste this into your
unix-like shell now:

<CodeSample>
```bash
alias gunwip='git log -n 1 | grep -q -c "\-\-wip\-\-" && git reset HEAD~1'
alias gwip='git add -A; git rm $(git ls-files --deleted) 2> /dev/null; git commit --no-verify --no-gpg-sign --message "--wip-- [skip ci]"'
```
</CodeSample>

## Clone the Companion Repo for Interactive Examples

There is a [companion repo](https://github.com/jdevries3133/git_some_help) to
accompany this post. Clone it, then `cd` into it and pull all the remote
branches with `git pull --all`

## Staging Hunks with `git add -i`, VSCode, or Vim

After cloning the [companion
repo](https://github.com/jdevries3133/git_some_help), checkout to the branch
`origin/interactive_staging`, and do a `gunwip`. `git diff` should then provide
the following output:

<CodeSample>
```diff
diff --git a/feature.txt b/feature.txt
index 30dbb2c..7f9611b 100644
--- a/feature.txt
+++ b/feature.txt
@@ -1,3 +1,5 @@
+New feature! Great stuff.
+
 This is pre-existing stuff.

-It existed before you started yur feature.
+It existed before you started your feature.
```
</CodeSample>

As you can see, we have two unrelated changes to `feature.txt`. First, we have
our new feature at the top, and later a change to a pre-existing spelling
mistake. Often, when we're working on a feature, we find things along the way
that we want to adjust: refactoring something janky, rewording a comment, or
even just fixing a spelling mistake. Ideally, we want to make these changes to
improve the code, but it is also natural to hesitate to touch any source code
outside the scope of the feature we're working on, since it'll make our commit
history sloppy. Every commit must be singularly focused, concise, and atomic,
but the minute-to-minute workflow in a codebase isn't necessarily like that.
We need to be able to create commits that comprise a subset of the changes in
our working tree, and that's exactly where interactive staging becomes useful.

### Interactive Staging from the Command Line

`git add --interactive` (or `git add -i`) will send you into an interactive
REPL (read evaluate print loop) where you can stage and unstage chunks of code
one at a time. You can try it out locally now, and here's what you should see:

<CodeSample>
```text
           staged     unstaged path
  1:    unchanged        +3/-1 feature.txt

*** Commands ***
  1: status       2: update       3: revert       4: add untracked
  5: patch        6: diff         7: quit         8: help
What now> 8
status        - show paths with changes
update        - add working tree state to the staged set of changes
revert        - revert staged set of changes back to the HEAD version
patch         - pick hunks and update selectively
diff          - view diff between HEAD and index
add untracked - add contents of untracked files to the staged set of changes
```
</CodeSample>

Git prints out the list of modified files (just one in this case). The command
we're most interested in is the "patch" command, which is where we can go
through the changes in a single file and granularly stage changes one chunk at
a time.

After pressing `p` for patch, git will ask you to choose your file, enter `1`,
since there's only one choice, and git will cycle through changes one by one,
prompting you for what to do. Here's what I see on our `feature.txt` file:

<CodeSample>
```diff
diff --git a/feature.txt b/feature.txt
index 30dbb2c..7f9611b 100644
--- a/feature.txt
+++ b/feature.txt
@@ -1,3 +1,5 @@
+New feature! Great stuff.
+
 This is pre-existing stuff.

-It existed before you started yur feature.
+It existed before you started your feature.
(1/1) Stage this hunk [y,n,q,a,d,s,e,?]? ?
y - stage this hunk
n - do not stage this hunk
q - quit; do not stage this hunk or any of the remaining ones
a - stage this hunk and all later hunks in the file
d - do not stage this hunk or any of the later hunks in the file
s - split the current hunk into smaller hunks
e - manually edit the current hunk
? - print help
```
</CodeSample>

Uh oh, git is viewing both of my changes as the same hunk! No worries, I can
use the `s` command:

<CodeSample>
```diff
(1/1) Stage this hunk [y,n,q,a,d,s,e,?]? s
Split into 2 hunks.
@@ -1,2 +1,4 @@
+New feature! Great stuff.
+
 This is pre-existing stuff.

(1/2) Stage this hunk [y,n,q,a,d,j,J,g,/,e,?]?
```
</CodeSample>

Much better! Now it's just showing me that first chunk of changes.

Go ahead and experiment. When you are satisfied with the subset of  changes you
have, exit the tool and make a commit as usual. Your goal is to end up with two
separate commits that isolate the feature from the spelling fix.

The correct answer is demonstrated on the [`origin/interactive_staging_answer`
branch](https://github.com/jdevries3133/git_some_help/commits/interactive_staging_answer).

### Interactive Staging with the VSCode

First, run `git reset --hard origin/interactive_staging` to restore the state
of your local branch to the remote branch, then `gunwip` again. This should
bring your local environment back to the state at the beginning of the last
example.

You can also interactively add changes inside VSCode.

<a title="View Large in New Tab" href="/static/vsCodeGitInteractiveStaging.webp" rel="noopener noreferrer" target="_blank">
  <Image
    src="/static/vsCodeGitInteractiveStaging.webp"
    alt="Screenshot of interactive staging in VSCode"
    caption="Interactive staging in VS Code"
  />
</a>

### Interactive Staging with Vim

In _*my opinion*_, nothing gets better than vim and [git
fugitive](https://github.com/tpope/vim-fugitive). You can use `:Gdiff` to open
a diff view for a file. You can use `dp` (diff put) to push changes from the
side your cursor is currently on to the opposite side, or `dg` (diff get) to
pull changes from the opposing side of the diff into your side. You can also
directly edit either side of the diff. This offers very granular control over
exactly what is staged versus unstaged.

<a title="View Large in New Tab" href="/static/interactiveStagingVim.webp" rel="noopener noreferrer" target="_blank">
  <Image
    src="/static/interactiveStagingVim.webp"
    alt="Screenshot of interactive staging in Vim"
    caption="Interactive staging in Vim"
  />
</a>

## Cherry-Picking

`git cherry-pick` is simple but sometimes super useful. Let's say you build
some super handy developer tooling features for your team. It would really help
for a feature you're developing, but it's currently trapped in code-review
purgatory. The feature exists on a different branch, but you want it on your
dev branch for this feature so that you can use it right now!

It turns out, you can snatch a commit by it's SHA-1 hash from any branch with
git cherry-pick.

For this demo, start by checking out to the `cherry_pick` branch; it's the same
as the main branch.

```bash
git checkout origin/cherry_pick
```

Now, we have a branch `origin/cool_new_features`. It has three new features on
it. Here's another trick: did you know you can pass a branch name to `git log`,
so we can inspect what is on `origin/cool_new_feature` without needing to
actually checkout again. Just run `git log origin/cool_new_feature`, and you
should see the following output.


<CodeSample>
```text
commit 81e142ae6eb5d85854af48f639a7fd3c368a7755 (origin/cool_new_features, cool_new_features)
Author: Jack DeVries <jdevries3133@gmail.com>
Date:   Sun Oct 16 17:42:09 2022 -0400

    feature three

commit fdd0fbb5ce7190f3cb7d2c33ae9dbc3137a923e4
Author: Jack DeVries <jdevries3133@gmail.com>
Date:   Sun Oct 16 17:41:58 2022 -0400

    feature two

commit aa7d855ad3bdb56b8400318e1fed9da88d3bfe13
Author: Jack DeVries <jdevries3133@gmail.com>
Date:   Sun Oct 16 17:41:46 2022 -0400

    feature one

commit 27c637c175fe617aca38f6df62e895742861857b (HEAD -> cherry_pick, origin/main, main)
Author: Jack DeVries <jdevries3133@gmail.com>
Date:   Sun Oct 16 16:22:39 2022 -0400

    initial commit & readme
```
</CodeSample>

From here, we can very easily yank "feature two" onto our dev branch
("`cherry_pick`") as follows:

```
git cherry-pick fdd0fbb5ce7190f3cb7d2c33ae9dbc3137a923e4
```

After running this command, do a `git log` to see that "feature two," and none
of the other features from `origin/cool_new_features`, are now on your dev
branch. You should see the following history:

<CodeSample>
```text
commit e24d759232f286de07247a0d54b4260e231f03c0 (HEAD -> cherry_pick)
Author: Jack DeVries <jdevries3133@gmail.com>
Date:   Sun Oct 16 17:41:58 2022 -0400

    feature two

 feat_two.txt | 1 +
 1 file changed, 1 insertion(+)

commit 27c637c175fe617aca38f6df62e895742861857b (origin/main, main)
Author: Jack DeVries <jdevries3133@gmail.com>
Date:   Sun Oct 16 16:22:39 2022 -0400

    initial commit & readme

 README.md | 4 ++++
 1 file changed, 4 insertions(+)
```
</CodeSample>

## Understanding Merge Commits

Let's dive deep into the wonky and wonderful world of merge commits. Every time
you merge two branches, the merge commit of those two branches is exactly the
same. Git has no understanding of which of the two is "main" or "master"; it
only combines them. We can demonstrate this by creating two branches, `A`, and
`B`. If we create different commits on each, then merge `A` into `B` and `B`
into `A`, we'll notice that the git hash at the tip of the branches becomes the
same; the branches are, at that moment, exactly equivalent.

This is demonstrated on the example repo with the branches `merge_a`, and
`merge_b`. Try it out to see for yourself:

```bash
$ echo "A: $(git rev-parse origin/merge_a)"
A: bf48661afb198965704cd30ae205add341d3ede8
$ echo "B: $(git rev-parse origin/merge_b)"
B: bf48661afb198965704cd30ae205add341d3ede8
```

To dig in a bit deeper, I created a bunch of "dev branches" off of `main` on
our repo, and merged them each back in with a few unique changes. As you can
see, I intentionally made the lifecycles of these dev branches criss-cross so
that we can see many scenarios.

Here's a quick overview of all the dev branches that exist:

```bash
$ git branch --remote | grep dev
origin/dev_branch
origin/dev_branch_two
origin/dev_branch_three
origin/dev_branch_four
origin/dev_branch_five
```


The only file changed throughout all this is `example.txt`. Here's what it
looks like at the end:

```text
change one
change two
change three
change on branch two number one
change on branch two number two
change on branch two number three
change four
change five
change six
dev branch 3 #1
dev branch 3 #2
dev branch 3 #3
misc commit x
misc commit y
misc commit z
dev branch 4 #1
dev branch 4 #2
dev branch 4 #3
dev branch 5 #1
dev branch 5 #2
dev branch 5 #3
```

Now, each line in the file above belongs to a commit in the history below. Line
content and commit message always matches, except for the initial commit and
merge commits throughout.

<a title="View Large in New Tab" href="/static/crissCrossHistory.webp" rel="noopener noreferrer" target="_blank">
  <Image
    src="/static/crissCrossHistory.webp"
    alt="A visual of criss-crossing git histories."
    caption={<p>Result of{" "} <code>git log --oneline --decorate --graph</code></p>}
  />
</a>

What's amazing if you hadn't realized this before is that git keeps track of
these many concurrent versions of history forever. Although `git log` makes it
look like history is linear, it really isn't. If you checkout to a commit on
one of these branches, the state of the source tree is exactly as it was when
you were working on that commit on the dev branch. For example, look at
`dev_branch_five`. I intentionally branched off an early commit in the history,
and didn't land it back on `main` until the very end. As such, you can see the
green line snaking through the whole history. Focus on `7b7f59a`, it's the
second commit from the top. If you were looking at `git log`, which squashes
this history into a linear progression, you'd probably think that `7b7f59a`
contains all the stuff that _apparently_ precedes it. Actually, if you checkout
to this commit, you'll see that it only contains the commits on that green
line! In other words, only the commits from `dev_branch_five` itself, as well
as the original `dev_branch`. A bash snippet is worth a thousand words, it
seems; give it a try:

```text
$ git checkout 7b7f59a \
      && cat example.txt \
      && git checkout -
change one
change two
change three
dev branch 5 #1
dev branch 5 #2
dev branch 5 #3
```

## Reverting Commits

With all that newfound knowledge, we can start to understand what is going on
when we try to revert one of these merge commits, and get the following
message:

<CodeSample>
```text
$ git revert 4608cadcaa71390123e23cb1614ad4d1c4928aaf
error: commit 4608cadcaa71390123e23cb1614ad4d1c4928aaf is a merge but no -m
option was given.
fatal: revert failed
```
</CodeSample>

Spooky, but no worries, let's see what the man page says for the `-m` option of
`git revert`!

<CodeSample>
```text
-m parent-number, --mainline parent-number

    Usually you cannot revert a merge because you do not know which side of the
    merge should be considered the mainline. This option specifies the parent
    number (starting from 1) of the mainline and allows revert to reverse the
    change relative to the specified parent.

    Reverting a merge commit declares that you will never want the tree changes
    brought in by the merge. As a result, later merges will only bring in tree
    changes introduced by commits that are not ancestors of the previously
    reverted merge. This may or may not be what you want.

    See the revert-a-faulty-merge How-To[1] for more details.
```
</CodeSample>

Yeah, totally self explanatory! Anyway, to quote myself from a few paragraphs
ago:

> Every time you merge two branches, the merge commit of those two branches is
> exactly the same. Git has no understanding of which of the two is "main" or
> "master"; it only combines them.

As we saw, after `merge_a` and `merge_b` were merged into each other, they had
the same exact git hash. Every merge commit, therefore, represents a "fork in
the road" if we're trying to travel backwards through history; and git doesn't
have any affinity for one path over the other. Except, the fork in the road
analogy has a caveat: the road does generally come back together again a few
commits later.

Let's focus on this piece of history on `main`:

<CodeSample>
```text
* 2b4f4f4 Merge branch 'dev_branch'
|\
| * c5b380a change three
| * 237db4d change two
| * 236e6ec change one
|/
* 27c637c (merge_two.txt, merge_two) initial commit & readme
```
</CodeSample>

Reverting `2b4f4f4` implies that either the code on the left side will be
reverted (purple), or the code on the right (string of stars). Obviously, if
we're trying to undo everything that happened in that dev branch, we want to
throw away the branch on the right side and keep what's on the left, discarding
the commits created on the dev branch. Git, however, cannot help us. We need to
help ourselves. We can help ourselves with the `-m` flag.

Count the possible branches from left to right. In this case, we have only two
options. If we revert with `-m 1`, git keeps the first path, discarding all
others. This is what we want. If, however, we say `-m 2`, nothing will actually
happen! That's because there are no commits on the left side of history. Try it
out!

<CodeSample>
```text
# when we try to discard the history on the left side, git tells us there is
# nothing to do
$ git revert -m 2 2b4f4f4
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean
```
</CodeSample>

If there were an intermediary commit on the left side, though, passing `-m 2`
would keep the history on the right and remove what's on the left; removing
commits that might be completely unrelated to what we're trying to revert!

Looking back at the full history, there is an example like that: reverting the
merge commit for `dev_branch_five`. Experiment, and see what happens when you
keep the history on the left, versus the history on the right! Obviously, the
two histories are quite different, so experimentation here should give you a
feel for what is happening. If you choose `-m 1`, you will revert
`dev_branch_five` as we understand it. If, on the other hand, you pass `-m 2`,
you'll tell git to use the full history of `dev_branch_five` and abandon what
we know as a bunch of work on `main`! <span className="text-sm italic">(I
didn't get time to test it, let's experiment and confirm whether this is the
case!)</span>

Keep in mind that if you're consistently merging into `main`, and every
non-main branch only branches away once and branches back once, reverting merge
commits should be simple. If, however, you're using git flow, where you have
many possible target branches, and maybe also long-lived dev branches, the
history graph as visualized earlier can start grow towards the right side of
your screen, and there can be many possible paths for reverting merge commits.

## Reflog and Interactive Rebasing

No time to finish off this section...

<Image
  src="/static/doItLive.webp"
  alt="Screenshot of Bill O'Reily's famous 'Fuck it, we'll do it live!' moment"
  caption="We'll do it live!"
/>
